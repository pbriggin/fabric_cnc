#!/usr/bin/env python3
"""
Toolpath Generator for Fabric CNC

Takes output from DXF processor and generates GCODE with:
- X, Y positioning
- Z height management (raise at corners with angle changes > 5 degrees)
- Z rotation (cutting blade parallel to current segment)
- Corner handling: raise Z → rotate Z → lower Z
"""

import math
import logging
from typing import Dict, List, Tuple, Optional
from dxf_processor import DXFProcessor

# Set up logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class ToolpathGenerator:
    """
    Generates GCODE toolpaths from DXF shapes with intelligent Z-axis management.
    """
    
    def __init__(self, 
                 cutting_height: float = -2.0,
                 safe_height: float = 5.0,
                 corner_angle_threshold: float = 15.0,  # Increased from 5.0 to be less sensitive to curves
                 feed_rate: float = 1000.0,
                 plunge_rate: float = 200.0):
        """
        Initialize the toolpath generator.
        
        Args:
            cutting_height: Z height when cutting (negative = below surface)
            safe_height: Z height when moving between cuts (positive = above surface)
            corner_angle_threshold: Angle in degrees above which to raise Z at corners
            feed_rate: Feed rate for cutting moves (mm/min)
            plunge_rate: Feed rate for Z plunges (mm/min)
        """
        self.cutting_height = cutting_height
        self.safe_height = safe_height
        self.corner_angle_threshold_radians = math.radians(corner_angle_threshold)
        self.feed_rate = feed_rate
        self.plunge_rate = plunge_rate
        self.current_z = safe_height  # Track current Z position
        
    def generate_toolpath(self, shapes: Dict[str, List[Tuple[float, float]]]) -> str:
        """
        Generate GCODE from DXF shapes.
        
        Args:
            shapes: Dictionary of shape names to point lists from DXF processor
            
        Returns:
            GCODE string
        """
        gcode_lines = []
        
        # Add header
        gcode_lines.extend(self._generate_header())
        
        # Process each shape
        for shape_name, points in shapes.items():
            logger.info(f"Generating toolpath for {shape_name} with {len(points)} points")
            shape_gcode = self._generate_shape_toolpath(shape_name, points)
            gcode_lines.extend(shape_gcode)
        
        # Add footer
        gcode_lines.extend(self._generate_footer())
        
        return '\n'.join(gcode_lines)
    
    def _generate_header(self) -> List[str]:
        """Generate GCODE header."""
        return [
            "; Fabric CNC Toolpath",
            "; Generated by ToolpathGenerator",
            "",
            "G21 ; Set units to millimeters",
            "G90 ; Set absolute positioning",
            "G28 ; Home all axes",
            "",
            f"G0 Z{self.safe_height} ; Move to safe height",
            ""
        ]
    
    def _generate_footer(self) -> List[str]:
        """Generate GCODE footer."""
        return [
            "",
            f"G0 Z{self.safe_height} ; Move to safe height",
            "G28 ; Home all axes",
            "M2 ; End program"
        ]
    
    def _generate_shape_toolpath(self, shape_name: str, points: List[Tuple[float, float]]) -> List[str]:
        """
        Generate GCODE for a single shape.
        
        Args:
            shape_name: Name of the shape
            points: List of (x, y) coordinate tuples
            
        Returns:
            List of GCODE lines for this shape
        """
        if len(points) < 2:
            logger.warning(f"Shape {shape_name} has less than 2 points, skipping")
            return []
        
        gcode_lines = []
        
        # Add shape comment
        gcode_lines.append(f"; Shape: {shape_name}")
        
        # Start at first point
        first_point = points[0]
        gcode_lines.append(f"G0 X{first_point[0]:.3f} Y{first_point[1]:.3f} ; Move to start")
        gcode_lines.append(f"G0 Z{self.cutting_height} ; Plunge to cutting height")
        
        # Process each segment
        for i in range(len(points) - 1):
            current_point = points[i]
            next_point = points[i + 1]
            
            # Calculate angle between current segment and next segment
            angle_change = self._calculate_angle_change(points, i)
            
            # Determine if we need to raise Z at this corner using simple angle detection
            should_raise_z = self._is_genuine_corner(points, i)
            
            # Calculate Z rotation for the next segment
            z_rotation = self._calculate_z_rotation(current_point, next_point)
            
            if should_raise_z:
                # Raise Z, rotate Z, move to next point, then plunge
                gcode_lines.append(f"G0 Z{self.safe_height} ; Raise Z for corner")
                gcode_lines.append(f"G0 A{z_rotation:.3f} ; Rotate Z for corner")
                gcode_lines.append(f"G0 X{next_point[0]:.3f} Y{next_point[1]:.3f} ; Move to next point")
                gcode_lines.append(f"G1 Z{self.cutting_height} F{self.plunge_rate} ; Lower Z to cutting height")
            else:
                # Direct move to next point (Z stays at cutting height)
                gcode_lines.append(f"G1 X{next_point[0]:.3f} Y{next_point[1]:.3f} A{z_rotation:.3f} F{self.feed_rate} ; Cut to next point")
        
        # If shape is closed, handle the last segment
        if len(points) > 2:
            last_point = points[-1]
            first_point = points[0]
            
            # Check if shape is closed (last point close to first point)
            distance = math.sqrt((last_point[0] - first_point[0])**2 + (last_point[1] - first_point[1])**2)
            logger.info(f"Shape closure distance: {distance}")
            if distance < 0.001:  # Shape is closed
                # For closed shapes, check the second-to-last point for the corner
                # (the transition from curve to final straight line)
                second_to_last_index = len(points) - 2
                should_raise_z = self._is_genuine_corner(points, second_to_last_index)
                logger.info(f"Should raise Z for closed shape: {should_raise_z}")
                
                # Calculate Z rotation for the final segment
                z_rotation = self._calculate_z_rotation(last_point, first_point)
                
                if should_raise_z:
                    gcode_lines.append(f"G0 Z{self.safe_height} ; Raise Z for final corner")
                    gcode_lines.append(f"G0 A{z_rotation:.3f} ; Rotate Z for final corner")
                    gcode_lines.append(f"G0 X{first_point[0]:.3f} Y{first_point[1]:.3f} ; Move to start")
                    gcode_lines.append(f"G1 Z{self.cutting_height} F{self.plunge_rate} ; Lower Z to cutting height")
                else:
                    gcode_lines.append(f"G1 X{first_point[0]:.3f} Y{first_point[1]:.3f} A{z_rotation:.3f} F{self.feed_rate} ; Close shape")
        
        # Raise Z at end of shape
        gcode_lines.append(f"G0 Z{self.safe_height} ; Raise Z after shape")
        gcode_lines.append("")
        
        return gcode_lines
    
    def _calculate_angle_change(self, points: List[Tuple[float, float]], point_index: int) -> float:
        """
        Calculate the angle change at a specific point.
        
        Args:
            points: List of points
            point_index: Index of the point to calculate angle change at
            
        Returns:
            Angle change in radians
        """
        if point_index == 0 or point_index >= len(points) - 1:
            return 0.0
        
        # Get three consecutive points
        prev_point = points[point_index - 1]
        current_point = points[point_index]
        next_point = points[point_index + 1]
        
        # Calculate vectors
        v1 = (current_point[0] - prev_point[0], current_point[1] - prev_point[1])
        v2 = (next_point[0] - current_point[0], next_point[1] - current_point[1])
        
        # Calculate magnitudes
        mag1 = math.sqrt(v1[0]**2 + v1[1]**2)
        mag2 = math.sqrt(v2[0]**2 + v2[1]**2)
        
        if mag1 == 0 or mag2 == 0:
            return 0.0
        
        # Calculate dot product
        dot_product = v1[0] * v2[0] + v1[1] * v2[1]
        
        # Calculate angle
        cos_angle = dot_product / (mag1 * mag2)
        cos_angle = max(-1, min(1, cos_angle))  # Clamp to [-1, 1]
        
        angle = math.acos(cos_angle)
        
        # Determine sign using cross product
        cross_product = v1[0] * v2[1] - v1[1] * v2[0]
        if cross_product < 0:
            angle = -angle
        
        return angle
    
    def _is_genuine_corner(self, points: List[Tuple[float, float]], point_index: int) -> bool:
        """
        Determine if a point represents a corner using simple angle-based detection.
        
        Args:
            points: List of points
            point_index: Index of the point to check
            
        Returns:
            True if this is a corner (angle > 5 degrees), False otherwise
        """
        if point_index == 0 or point_index >= len(points) - 1:
            return False
        
        # Get three consecutive points
        prev_point = points[point_index - 1]
        current_point = points[point_index]
        next_point = points[point_index + 1]
        
        # Calculate vectors
        v1 = (current_point[0] - prev_point[0], current_point[1] - prev_point[1])
        v2 = (next_point[0] - current_point[0], next_point[1] - current_point[1])
        
        # Calculate magnitudes
        mag1 = math.sqrt(v1[0]**2 + v1[1]**2)
        mag2 = math.sqrt(v2[0]**2 + v2[1]**2)
        
        if mag1 == 0 or mag2 == 0:
            return False
        
        # Calculate dot product
        dot_product = v1[0] * v2[0] + v1[1] * v2[1]
        
        # Calculate angle using the exact formula from Google Sheets
        cos_angle = dot_product / (mag1 * mag2)
        cos_angle = max(-1, min(1, cos_angle))  # Clamp to [-1, 1]
        
        angle_radians = math.acos(cos_angle)
        angle_degrees = math.degrees(angle_radians)
        
        # Debug output
        if angle_degrees > 5.0:
            logger.info(f"Point {point_index}: angle = {angle_degrees:.3f}° -> CORNER")
        else:
            logger.info(f"Point {point_index}: angle = {angle_degrees:.3f}° -> not a corner")
        
        # If angle > 10 degrees, it's a corner
        return angle_degrees > 10.0
    
    def _calculate_z_rotation(self, point1: Tuple[float, float], point2: Tuple[float, float]) -> float:
        """
        Calculate Z rotation angle to make cutting blade parallel to line segment.
        
        Args:
            point1: First point (x, y)
            point2: Second point (x, y)
            
        Returns:
            Z rotation angle in degrees
        """
        dx = point2[0] - point1[0]
        dy = point2[1] - point1[1]
        
        # Calculate angle from X-axis
        angle_radians = math.atan2(dy, dx)
        
        # Convert to degrees
        angle_degrees = math.degrees(angle_radians)
        
        return angle_degrees


def main():
    """Test the toolpath generator with the DXF processor output."""
    # Initialize processors
    dxf_processor = DXFProcessor()
    toolpath_generator = ToolpathGenerator(
        cutting_height=-2.0,
        safe_height=5.0,
        corner_angle_threshold=2.0,
        feed_rate=1000.0,
        plunge_rate=200.0
    )
    
    # Process DXF file
    dxf_path = "test_2.dxf"
    
    try:
        # Get shapes from DXF processor
        shapes = dxf_processor.process_dxf(dxf_path)
        
        if not shapes:
            print("No shapes found in DXF file")
            return
        
        print(f"Processing {len(shapes)} shapes for toolpath generation...")
        
        # Generate toolpath
        gcode = toolpath_generator.generate_toolpath(shapes)
        
        # Save GCODE to file
        output_filename = f"toolpath_{dxf_path.split('/')[-1].replace('.dxf', '.gcode')}"
        with open(output_filename, 'w') as f:
            f.write(gcode)
        
        print(f"Toolpath saved to: {output_filename}")
        print(f"Generated {len(gcode.split(chr(10)))} lines of GCODE")
        
        # Show first few lines as preview
        print("\nGCODE Preview (first 20 lines):")
        print("-" * 50)
        lines = gcode.split('\n')
        for i, line in enumerate(lines[:20]):
            print(f"{i+1:3d}: {line}")
        if len(lines) > 20:
            print("...")
        
    except Exception as e:
        print(f"Error generating toolpath: {e}")
        import traceback
        traceback.print_exc()


if __name__ == "__main__":
    main() 